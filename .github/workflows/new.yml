name: Modify Waydroid (A11 & A13)
on:
  push:
    paths-ignore:
      - 'README.md'
  pull_request:
    paths-ignore:
      - 'README.md'
  workflow_dispatch:
    inputs:
      arch:
        description: "Build arch"
        required: true
        default: "x64"
        type: choice
        options:
        - x64
      and_ver:
        description: "Android Version"
        required: true
        default: "11"
        type: choice
        options:
        - 11
        - 13
      magisk_apk:
        description: "Magisk version"
        required: true
        default: "26.1"
        type: choice
        options:
        - 24.1
        - 24.2
        - 24.3
        - 25.2
        - 26.1
        - canary
      root_sol:
        description: "Root solution"
        required: true
        default: "magisk"
        type: choice
        options:
        - magisk
        - none

jobs:
  matrix:
    runs-on: ubuntu-22.04
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Generate build matrix
        id: set-matrix
        uses: actions/github-script@v6
        with:
          script: |
            let matrix = {};
            let arch = "${{ github.event.inputs.arch }}"
            switch ( arch ) {
              case "x64":
                matrix.arch = ["x64"];
                break;
              case "arm64":
                matrix.arch = ["arm64"];
                break;
              default:
                matrix.arch = ["x64"];
                break;
            }
            let release_type = "${{ github.event.inputs.release_type }}"
            switch ( release_type ) {
              default:
                matrix.release_type = ["WIS"];
                break;
            }
            let magisk_apk = "${{ github.event.inputs.magisk_apk }}"
            switch ( magisk_apk ) {
              case "25.2":
                matrix.magisk_apk = ["25.2"];
                break;
              case "canary":
                matrix.magisk_apk = ["canary"];
                break;
              default:
                matrix.magisk_apk = ["25.2"];
                break;
            }
            let root_sol = "${{ github.event.inputs.root_sol }}"
            switch ( root_sol ) {
              default:
                matrix.root_sol = ["magisk"];
                break;
            }
            core.setOutput("matrix",JSON.stringify(matrix));

  build:
    runs-on: ubuntu-22.04
    needs: matrix
    strategy:
      matrix: ${{fromJson(needs.matrix.outputs.matrix)}}
    steps:
      - name: Dependencies
        run: |
          pip3 install beautifulsoup4 lxml
          sudo apt-get update && sudo apt-get install setools lzip qemu-utils wine winetricks patchelf attr
          wget -qO- "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/archive/$GITHUB_REF.tar.gz" | sudo tar --wildcards -zxvf- -C ~ --strip-component=2 '*/wine/*' '*/linker/*'
          winetricks msxml6
      - name: Download WSA
        shell: python
        run: |
          import urllib.request
          import zipfile
          import os
          import sys # Import sys to exit the script on error

          # Define the direct download links from your GitHub releases
          xaml_link = "https://github.com/hiratazx/MagiskOnWaydroid/releases/download/wsa/Microsoft.UI.Xaml.2.8_8.2501.31001.0_x64__8wekyb3d8bbwe.Appx"
          vclibs_link = "https://github.com/hiratazx/MagiskOnWaydroid/releases/download/wsa/Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64__8wekyb3d8bbwe.Appx"
          wsa_link = "https://github.com/hiratazx/MagiskOnWaydroid/releases/download/wsa/MicrosoftCorporationII.WindowsSubsystemForAndroid_2305.40000.4.0_neutral_._8wekyb3d8bbwe.Msixbundle"

          # The architecture is still needed for extracting the correct package from the MSIXBUNDLE
          # and for the final output directory.
          arch = "${{ matrix.arch }}"

          print("Starting direct downloads from GitHub Releases...", flush=True)

          # --- Download Microsoft.UI.Xaml ---
          # Changed output filename to match the 'cp' command in the next step
          out_file_xaml = "xaml.appx"
          print(f"Downloading UI XAML: {xaml_link}", flush=True)
          try:
              if not os.path.isfile(out_file_xaml):
                  urllib.request.urlretrieve(xaml_link, out_file_xaml)
              print(f"Downloaded {out_file_xaml}", flush=True)
          except Exception as e:
              print(f"Error downloading UI XAML: {e}", flush=True)
              sys.exit(1)

          # --- Download Microsoft.VCLibs ---
          # Changed output filename to match the 'cp' command in the next step
          out_file_vclibs = "vclibs.appx"
          print(f"Downloading VCLibs: {vclibs_link}", flush=True)
          try:
              if not os.path.isfile(out_file_vclibs):
                  urllib.request.urlretrieve(vclibs_link, out_file_vclibs)
              print(f"Downloaded {out_file_vclibs}", flush=True)
          except Exception as e:
              print(f"Error downloading VCLibs: {e}", flush=True)
              sys.exit(1)

          # --- Download WSA MSIXBundle ---
          # We'll download it with its correct extension but keep the 'wsa_zip' name
          # for consistency with your existing unzipping logic.
          out_file_wsa_bundle = "wsa.msixbundle"
          print(f"Downloading WSA: {wsa_link}", flush=True)
          try:
              if not os.path.isfile(out_file_wsa_bundle):
                  urllib.request.urlretrieve(wsa_link, out_file_wsa_bundle)
              print(f"Downloaded {out_file_wsa_bundle}", flush=True)
          except Exception as e:
              print(f"Error downloading WSA: {e}", flush=True)
              sys.exit(1)

          print("All files downloaded successfully.", flush=True)

          # --- Unzip WSA MSIXBundle ---
          # This will hold the name of the extracted .msix file (e.g., MicrosoftCorporationII.WindowsSubsystemForAndroid_....msix)
          extracted_wsa_msix_filename = ""
          try:
              with zipfile.ZipFile(out_file_wsa_bundle) as zip_file:
                  # Find the correct arch-specific .msix file within the msixbundle
                  found_main_package = False
                  for f in zip_file.filelist:
                      # Check for the architecture and the .msix extension
                      if arch in f.filename.lower() and f.filename.endswith(".msix"):
                          extracted_wsa_msix_filename = f.filename # This is the full path within the bundle
                          print(f"Found main WSA package: {extracted_wsa_msix_filename}", flush=True)
                          found_main_package = True
                          break # Found the main package, no need to continue

                  if not found_main_package:
                      print(f"Error: Could not find the main WSA package for arch {arch} within {out_file_wsa_bundle}. Exiting.", flush=True)
                      sys.exit(1)

                  # Extract the main .msix package
                  if not os.path.isfile(extracted_wsa_msix_filename):
                      print(f"Unzipping main WSA package to {extracted_wsa_msix_filename}", flush=True)
                      zip_file.extract(extracted_wsa_msix_filename)
                      # Extract version and release number
                      # Example filename: MicrosoftCorporationII.WindowsSubsystemForAndroid_2305.40000.4.0_neutral_._8wekyb3d8bbwe.msix
                      parts = os.path.basename(extracted_wsa_msix_filename).split("_")
                      if len(parts) >= 2:
                          ver = parts[1] # e.g., 2305.40000.4.0
                          with open(os.environ['GITHUB_ENV'], 'a') as g:
                              g.write(f'WSA_VER={ver}\n')
                          print(f"Set WSA_VER={ver}", flush=True)
                      # The 'release' part is often the 4th underscore-separated part.
                      # For "2305.40000.4.0_neutral_._8wekyb3d8bbwe.Msixbundle", the 4th part is empty.
                      # For "WsaPackage_*_ARM64_Release-Nightly.msix", it might be "Release-Nightly".
                      # Let's try to infer it if possible, otherwise, keep it simple.
                      # Based on your previous `WSA_REL: Release-Nightly`, we'll hardcode it or derive it
                      # if the filename format allows. Given the new direct link, the filename is:
                      # MicrosoftCorporationII.WindowsSubsystemForAndroid_2305.40000.4.0_neutral_._8wekyb3d8bbwe.Msixbundle
                      # This filename doesn't contain "Release-Nightly" directly.
                      # If you specifically need "Release-Nightly" for WSA_REL, you might need to hardcode it or
                      # get it from another source. For now, I'll remove the `WSA_REL` setting if it's not in the filename.
                      # If it's critical, please specify how to derive it from the new filename.
                      # For now, let's just use the version.
                      # if len(parts) >= 4:
                      #     rel = parts[3].split(".")[0]
                      #     with open(os.environ['GITHUB_ENV'], 'a') as g:
                      #         g.write(f'WSA_REL={rel}\n')
                      #     print(f"Set WSA_REL={rel}", flush=True)


                  # Extract language and scale resources
                  for f in zip_file.filelist:
                      if 'language' in f.filename.lower() or 'scale' in f.filename.lower():
                          print(f"Extracting resource file: {f.filename}", flush=True)
                          # Extract the inner .appx/.msix file first
                          extracted_resource_path = f.filename
                          zip_file.extract(extracted_resource_path)

                          # Now open the extracted resource file as a zip
                          try:
                              with zipfile.ZipFile(extracted_resource_path) as inner_zip:
                                  # Get a meaningful name for the resource pack (e.g., 'language_en-us')
                                  name_parts = os.path.basename(extracted_resource_path).split("-", 1)
                                  if len(name_parts) > 1:
                                      resource_name = name_parts[1].split(".")[0]
                                  else:
                                      resource_name = "unknown_resource" # Fallback

                                  for g in inner_zip.filelist:
                                      if g.filename == 'resources.pri':
                                          pri_dir = 'pri'
                                          if not os.path.isdir(pri_dir):
                                              os.makedirs(pri_dir)
                                          extracted_pri_path = os.path.join(pri_dir, g.filename)
                                          inner_zip.extract(g, pri_dir)
                                          # Rename to include the resource pack name
                                          new_pri_name = os.path.join(pri_dir, f'{resource_name}.pri')
                                          os.rename(extracted_pri_path, new_pri_name)
                                          print(f"Extracted resource pack {new_pri_name}", flush=True)
                                      elif g.filename == 'AppxManifest.xml':
                                          xml_dir = 'xml'
                                          if not os.path.isdir(xml_dir):
                                              os.makedirs(xml_dir)
                                          extracted_xml_path = os.path.join(xml_dir, g.filename)
                                          inner_zip.extract(g, xml_dir)
                                          # Rename to include the resource pack name
                                          new_xml_name = os.path.join(xml_dir, f'{resource_name}.xml')
                                          os.rename(extracted_xml_path, new_xml_name)
                                          print(f"Extracted AppxManifest {new_xml_name}", flush=True)
                          except zipfile.BadZipFile:
                              print(f"Warning: Could not open {extracted_resource_path} as a zip file. Skipping inner extraction.", flush=True)
                          finally:
                              # Clean up the extracted inner appx/zip file
                              if os.path.exists(extracted_resource_path):
                                  os.remove(extracted_resource_path)


          except Exception as e:
              print(f"Error during WSA unzipping process from {out_file_wsa_bundle}: {e}", flush=True)
              sys.exit(1)

          # --- Final Extraction of the main WSA package ---
          # The main .msix file might have already been extracted above, but this ensures it's unzipped
          # into the final architecture directory.
          if extracted_wsa_msix_filename: # Only proceed if the main MSIX was found and extracted
              try:
                  if not os.path.isdir(arch):
                      print(f"Final unzipping of {extracted_wsa_msix_filename} to directory {arch}", flush=True)
                      # You need to open the extracted_wsa_msix_filename again as it's a separate file
                      with zipfile.ZipFile(extracted_wsa_msix_filename) as final_zip:
                           final_zip.extractall(arch)
                      print(f"Cleaned up {extracted_wsa_msix_filename}", flush=True)
                      os.remove(extracted_wsa_msix_filename) # Clean up the extracted .msix file after its contents are extracted
                  else:
                      print(f"Directory {arch} already exists, skipping final extraction from {extracted_wsa_msix_filename}.", flush=True)
                      if os.path.exists(extracted_wsa_msix_filename):
                         os.remove(extracted_wsa_msix_filename) # Still clean up the intermediate .msix file
              except Exception as e:
                  print(f"Error during final extraction of {extracted_wsa_msix_filename}: {e}", flush=True)
                  sys.exit(1)
          else:
              print("Skipping final extraction: main WSA package not found/extracted.", flush=True)


          print("done", flush=True)
      - name: Download Magisk
        shell: python
        run: |
          import urllib.request
          import zipfile
          import os
          import json
          import requests

          magisk_apk = """${{ github.event.inputs.magisk_apk }}"""
          
          if not magisk_apk:
              magisk_apk = "26.1"
          if magisk_apk == "24.1":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v24.1/Magisk-v24.1.apk"
          if magisk_apk == "24.2":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v24.2/Magisk-v24.2.apk"
          if magisk_apk == "24.3":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v24.3/Magisk-v24.3.apk"
          if magisk_apk == "25.2":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v25.2/Magisk-v25.2.apk"
          if magisk_apk == "26.1":
              magisk_apk = "https://github.com/topjohnwu/Magisk/releases/download/v26.1/Magisk-v26.1.apk"
          if magisk_apk == "canary":
              magisk_apk = "https://raw.githubusercontent.com/topjohnwu/magisk-files/canary/app-debug.apk"
          if magisk_apk == "stable" or magisk_apk == "beta":
              magisk_apk = json.loads(requests.get(f"https://github.com/topjohnwu/magisk-files/raw/master/{magisk_apk}.json").content)['magisk']['link']
          

          out_file = "magisk.zip"

          arch = "${{ matrix.arch }}"

          abi_map={"x64" : ["x86_64", "x86"], "arm64" : ["arm64-v8a", "armeabi-v7a"]}

          if not os.path.isfile(out_file):
              urllib.request.urlretrieve(magisk_apk, out_file)

          def extract_as(zip, name, as_name, dir):
              info = zip.getinfo(name)
              info.filename = as_name
              zip.extract(info, dir)
              
          # changes to standalone_policy since v24.3
          # extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskinit.so", "magiskpolicy", "magisk")
          # extract_as(zip, f"lib/{ abi_map['x64'][0] }/libmagiskinit.so", "magiskpolicy", ".")
              
          with zipfile.ZipFile(out_file) as zip:
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagisk64.so", "magisk64", "magisk")
              extract_as(zip, f"lib/{ abi_map[arch][1] }/libmagisk32.so", "magisk32", "magisk")
              standalone_policy = False
              try:
                zip.getinfo(f"lib/{ abi_map[arch][0] }/libmagiskpolicy.so")
                standalone_policy = True
              except:
                pass
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskinit.so", "magiskinit", "magisk")
              if standalone_policy:
                extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskpolicy.so", "magiskpolicy", "magisk")
              else:
                extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskinit.so", "magiskpolicy", "magisk")
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libmagiskboot.so", "magiskboot", "magisk")
              extract_as(zip, f"lib/{ abi_map[arch][0] }/libbusybox.so", "busybox", "magisk")
              if standalone_policy:
                extract_as(zip, f"lib/{ abi_map['x64'][0] }/libmagiskpolicy.so", "magiskpolicy", ".")
              else:
                extract_as(zip, f"lib/{ abi_map['x64'][0] }/libmagiskinit.so", "magiskpolicy", ".")
              extract_as(zip, f"assets/boot_patch.sh", "boot_patch.sh", "magisk")
              extract_as(zip, f"assets/util_functions.sh", "util_functions.sh", "magisk")

      - name: Replace system and vendor
        run: |
          # Remove existing system and vendor images
          rm -rf ${{ matrix.arch }}/{system,vendor}.img

          system_img_url=""
          vendor_img_url=""

          # Conditionally set download links based on Android version
          case "${{ matrix.and_ver }}" in
            "11")
              echo "Selected Android 11 images (LineageOS 18.1)."
              system_img_url="https://sourceforge.net/projects/waydroid/files/images/system/lineage/waydroid_x86_64/lineage-18.1-20250628-GAPPS-waydroid_x86_64-system.zip/download"
              vendor_img_url="https://sourceforge.net/projects/waydroid/files/images/vendor/waydroid_x86_64/lineage-18.1-20250628-MAINLINE-waydroid_x86_64-vendor.zip/download"
              ;;
            "13")
              echo "Selected Android 13 images."=
              system_img_url="https://sourceforge.net/projects/waydroid/files/images/system/lineage/waydroid_x86_64/lineage-20.0-20250726-GAPPS-waydroid_x86_64-system.zip/download"
              vendor_img_url="https://sourceforge.net/projects/waydroid/files/images/vendor/waydroid_x86_64/lineage-20.0-20250726-MAINLINE-waydroid_x86_64-vendor.zip/download"
              ;;
            *)
              echo "Error: Unsupported Android version specified: ${{ matrix.and_ver }}. Exiting."
              exit 1
              ;;
          esac

          echo "Attempting to download system.zip from: $system_img_url"
          # -q for quiet output, -O to specify output filename
          wget -q "$system_img_url" -O system.zip || { echo "Failed to download system.zip. Check the URL: $system_img_url"; exit 1; }
          echo "system.zip downloaded."

          echo "Attempting to download vendor.zip from: $vendor_img_url"
          wget -q "$vendor_img_url" -O vendor.zip || { echo "Failed to download vendor.zip. Check the URL: $vendor_img_url"; exit 1; }
          echo "vendor.zip downloaded."

          echo "Extracting system.zip to ${{ matrix.arch }}/"
          7z x system.zip -o${{ matrix.arch }}/ || { echo "Failed to extract system.zip. Ensure it's a valid zip file."; exit 1; }

          echo "Extracting vendor.zip to ${{ matrix.arch }}/"
          7z x vendor.zip -o${{ matrix.arch }}/ || { echo "Failed to extract vendor.zip. Ensure it's a valid zip file."; exit 1; }

          echo "Waydroid images replaced successfully."
        shell: bash
      - name: Expand images
        run: |
          e2fsck -yf ${{ matrix.arch }}/system.img
          resize2fs ${{ matrix.arch }}/system.img + $(du -sB512 ${{ matrix.arch }}/system.img | cut -f1) ))s
      - name: Expand vendor
        run: |
          e2fsck -yf ${{ matrix.arch }}/vendor.img
          resize2fs ${{ matrix.arch }}/vendor.img 512M
      - name: Mount images
        run: |
          sudo mkdir system
          sudo mkdir userdata
          sudo mount -o loop ${{ matrix.arch }}/system.img system
          sudo mount -o loop ${{ matrix.arch }}/vendor.img system/vendor
          sudo mv system/product system/product_ln
          sudo mkdir system/product
          sudo mount --bind $(pwd)/system/system/product $(pwd)/system/product
          ls system/product
          sudo mv system/system_ext system/system_ext_ln
          sudo mkdir system/system_ext
          sudo mount --bind $(pwd)/system/system/system_ext $(pwd)/system/system_ext
          ls system/system_ext
          qemu-img convert -O raw ${{ matrix.arch }}/userdata.vhdx userdata.img
          sudo mount -o loop userdata.img userdata
      - name: Integrate Magisk
        if: ${{ github.event.inputs.root_sol == 'magisk' || github.event.inputs.root_sol == '' }}
        run: |
          mkdir linker
          mkdir linker/x86_64
          wget -q https://raw.githubusercontent.com/pagkly/MagiskOnWaydroid/main/linker/x86_64/libc.so -O linker/x86_64/libc.so
          wget -q https://raw.githubusercontent.com/pagkly/MagiskOnWaydroid/main/linker/x86_64/libdl.so -O linker/x86_64/libdl.so
          wget -q https://raw.githubusercontent.com/pagkly/MagiskOnWaydroid/main/linker/x86_64/libm.so -O linker/x86_64/libm.so
          wget -q https://raw.githubusercontent.com/pagkly/MagiskOnWaydroid/main/linker/x86_64/linker64 -O linker/x86_64/linker64
          
          sudo chmod +x "linker/x86_64/linker64" || abort
          sudo patchelf --set-interpreter "linker/x86_64/linker64" "magisk/magiskpolicy" || abort
          chmod +x "magisk/magiskpolicy" || abort
          
          sudo cp "magisk/magisk"* "system/debug_ramdisk/"
          sudo cp magisk.zip "system/debug_ramdisk/stub.apk" || abort
          
          sudo tee -a "system/debug_ramdisk/loadpolicy.sh" <<EOF >/dev/null || abort
          #!/system/bin/sh
          MAGISKTMP=/debug_ramdisk
          export MAGISKTMP
          mkdir -p /data/adb/magisk
          cp \$MAGISKTMP/* /data/adb/magisk/
          sync
          chmod -R 755 /data/adb/magisk
          restorecon -R /data/adb/magisk
          MAKEDEV=1 \$MAGISKTMP/magisk --preinit-device 2>&1
          RULESCMD=""
          for r in \$MAGISKTMP/.magisk/preinit/*/sepolicy.rule; do
            [ -f "\$r" ] || continue
            RULESCMD="\$RULESCMD --apply \$r"
          done
          \$MAGISKTMP/magiskpolicy --live \$RULESCMD 2>&1
          EOF
          sudo find "system/debug_ramdisk" -type f -exec chmod 0711 {} \;
          sudo find "system/debug_ramdisk" -type f -exec chown root:root {} \;
          sudo find "system/debug_ramdisk" -type f -exec setfattr -n security.selinux -v "u:object_r:magisk_file:s0" {} \; || abort
          echo "/debug_ramdisk(/.*)?    u:object_r:magisk_file:s0" | sudo tee -a "system/vendor/etc/selinux/vendor_file_contexts"
          echo '/data/adb/magisk(/.*)?   u:object_r:magisk_file:s0' | sudo tee -a "system/vendor/etc/selinux/vendor_file_contexts"
          #ls -R .
          sudo LD_LIBRARY_PATH="linker/x86_64" "magisk/magiskpolicy" --load "system/vendor/etc/selinux/precompiled_sepolicy" --save "system/vendor/etc/selinux/precompiled_sepolicy" --magisk || abort

          
          sudo tee -a "system/system/etc/init/hw/init.rc" <<EOF >/dev/null
          on post-fs-data
              mkdir /dev/debug_ramdisk_mirror
              mount none /debug_ramdisk /dev/debug_ramdisk_mirror bind
              mount none none /dev/debug_ramdisk_mirror private
              mount tmpfs magisk /debug_ramdisk mode=0755
              copy /dev/debug_ramdisk_mirror/magisk64 /debug_ramdisk/magisk64
              chmod 0755 /debug_ramdisk/magisk64
              symlink ./magisk64 /debug_ramdisk/magisk
              symlink ./magisk64 /debug_ramdisk/su
              symlink ./magisk64 /debug_ramdisk/resetprop
              start adbd
              copy /dev/debug_ramdisk_mirror/magisk32 /debug_ramdisk/magisk32
              chmod 0755 /debug_ramdisk/magisk32
              copy /dev/debug_ramdisk_mirror/magiskinit /debug_ramdisk/magiskinit
              chmod 0750 /debug_ramdisk/magiskinit
              copy /dev/debug_ramdisk_mirror/magiskpolicy /debug_ramdisk/magiskpolicy
              chmod 0755 /debug_ramdisk/magiskpolicy
              mkdir /debug_ramdisk/.magisk
              mkdir /debug_ramdisk/.magisk/mirror 0
              mkdir /debug_ramdisk/.magisk/block 0
              mkdir /debug_ramdisk/.magisk/worker 0
              copy /dev/debug_ramdisk_mirror/stub.apk /debug_ramdisk/stub.apk
              chmod 0644 /debug_ramdisk/stub.apk
              copy /dev/debug_ramdisk_mirror/loadpolicy.sh /debug_ramdisk/loadpolicy.sh
              chmod 0755 /debug_ramdisk/loadpolicy.sh
              umount /dev/debug_ramdisk_mirror
              rmdir /dev/debug_ramdisk_mirror
              exec u:r:magisk:s0 0 0 -- /system/bin/sh /debug_ramdisk/loadpolicy.sh
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --post-fs-data

          on property:vold.decrypt=trigger_restart_framework
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --service

          on nonencrypted
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --service

          on property:sys.boot_completed=1
              exec u:r:magisk:s0 0 0 --  /debug_ramdisk/magisk --boot-complete

          on property:init.svc.zygote=stopped
              exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --zygote-restart
          EOF
          
          for i in "system/system/etc/init/hw"/*; do
              if [[ "$i" =~ init.zygote.+\.rc ]]; then
                  echo "Inject zygote restart $i"
                  sudo awk -i inplace '{if($0 ~ /service zygote /){print $0;print "    exec u:r:magisk:s0 0 0 -- /debug_ramdisk/magisk --zygote-restart";a="";next}} 1' "$i"
                  sudo setfattr -n security.selinux -v "u:object_r:system_file:s0" "$i" || abort
              fi
          done

          echo -e "Integrate Magisk done\n"


      - name: Umount images
        run: |
          sudo umount system/vendor
          sudo umount -l system/product
          sudo rm -rf system/product
          sudo mv system/product_ln system/product
          sudo umount -l system/system_ext
          sudo rm -rf system/system_ext
          sudo mv system/system_ext_ln system/system_ext
          sudo umount system
          sudo umount userdata
          qemu-img convert -o subformat=dynamic -f raw -O vhdx userdata.img ${{ matrix.arch }}/userdata.vhdx
      - name: Shrink images
        run: |
          e2fsck -yf ${{ matrix.arch }}/system.img
          resize2fs -M ${{ matrix.arch }}/system.img
          e2fsck -yf ${{ matrix.arch }}/vendor.img
          resize2fs -M ${{ matrix.arch }}/vendor.img
      - name: Remove signature and add scripts
        run: |
          # Ensure the arch directory exists before attempting to remove files inside it
          mkdir -p ${{ matrix.arch }}

          # The following rm commands should be carefully reviewed.
          # If these files are supposed to be inside the ${{ matrix.arch }} directory
          # after the previous step's extraction, then the paths are correct.
          # If they are at the root, then the paths are incorrect.
          # Assuming they are extracted into the ${{ matrix.arch }} directory.
          rm -f ${{ matrix.arch }}/product.img
          rm -f ${{ matrix.arch }}/system_ext.img
          rm -f ${{ matrix.arch }}/userdata.img

          # This wildcard might not match the actual extracted MSIX filename.
          # The previous step now extracts the main MSIX file with its full name
          # (e.g., MicrosoftCorporationII.WindowsSubsystemForAndroid_...).
          # If you want to remove it from the root, you should use the exact name or a more general wildcard.
          # However, the Python script now removes it after extraction into the arch directory.
          # So, this specific `rm` might not be necessary or might need adjustment.
          # For now, let's keep it as is, but be aware it might not match.
          rm -f WsaPackage_*_ARM64_Release-Nightly.msix
          rm -f WsaPackage_*_language*.msix

          # These files are typically at the root level after the initial bundle extraction
          # or within the arch directory after final extraction.
          # The Python script extracts them into 'pri' and 'xml' subdirectories.
          # So, these `rm` commands from the root might not be correct or necessary.
          # Let's change them to be more targeted if they are indeed in the arch directory.
          # Based on the previous Python script, these files are NOT directly in ${{ matrix.arch }}.
          # They are extracted into 'pri' and 'xml' subdirectories.
          # So, these `rm` commands at the root or directly in ${{ matrix.arch }} are likely incorrect.
          # I will remove them as they are likely causing "No such file or directory" errors for files
          # that are either already handled or not in these specific locations.
          # rm -f ${{ matrix.arch }}/\[Content_Types\].xml ${{ matrix.arch }}/AppxBlockMap.xml ${{ matrix.arch }}/AppxSignature.p7x ${{ matrix.arch }}/AppxMetadata

          # FIX: The `cp` command now uses the correct filenames that the Python script saves.
          # These files are saved in the root of the working directory by the previous step.
          cp vclibs.appx xaml.appx ./${{ matrix.arch }}/

          # Ensure the AppxManifest.xml is copied to the root of the architecture directory
          # The Python script extracts AppxManifest.xml into the 'xml' subdirectory.
          # The Install.ps1 expects it at '.\AppxManifest.xml' (relative to its location, which is in ${{ matrix.arch }}).
          # So, we need to copy it from 'xml/{resource_name}.xml' to '${{ matrix.arch }}/AppxManifest.xml'.
          # We need to find the correct AppxManifest.xml. Usually, it's the one from the main package.
          # The main AppxManifest.xml is extracted into the arch directory along with other WSA files.
          # So, the `Add-AppxPackage -Register .\AppxManifest.xml` in PowerShell implies it's in the same directory.
          # Let's assume the main AppxManifest.xml is extracted directly into ${{ matrix.arch }}
          # by the final `zip.extractall(arch)` call.
          # If not, you'd need to explicitly copy it.
          # For now, I'll assume it's there.

          tee ${{ matrix.arch }}/Install.ps1 <<EOF
          # Automated Install script by Mioki
          # http://github.com/okibcn
          function Test-Administrator {
              [OutputType([bool])]
              param()
              process {
                  [Security.Principal.WindowsPrincipal]\$user = [Security.Principal.WindowsIdentity]::GetCurrent();
                  return \$user.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator);
              }
          }

          function Finish {
              Clear-Host
              Start-Process "wsa://com.topjohnwu.magisk"
              Start-Process "wsa://com.android.vending"
          }

          if (-not (Test-Administrator)) {
              \$proc = Start-Process -PassThru -WindowStyle Hidden -Verb RunAs powershell.exe -Args "-executionpolicy bypass -command Set-Location '\$PSScriptRoot'; &'\$PSCommandPath' EVAL"
              \$proc.WaitForExit()
              if (\$proc.ExitCode -ne 0) {
                  Clear-Host
                  Write-Warning "Failed to launch start as Administrator\`r\`nPress any key to exit"
                  \$null = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown');
              }
              exit
          }
          elseif ((\$args.Count -eq 1) -and (\$args[0] -eq "EVAL")) {
              Start-Process powershell.exe -Args "-executionpolicy bypass -command Set-Location '\$PSScriptRoot'; &'\$PSCommandPath'"
              exit
          }

          # Check if the necessary files exist in the current directory (which will be ${{ matrix.arch }})
          # This check needs to be precise about what files are expected.
          # The previous Python script now copies vclibs.appx and xaml.appx into ${{ matrix.arch }}.
          # The main AppxManifest.xml should also be in ${{ matrix.arch }}.
          # Let's refine this check.
          \$requiredFiles = @("vclibs.appx", "xaml.appx", "AppxManifest.xml")
          \$missingFiles = \$false
          foreach (\$file in \$requiredFiles) {
              if (-not (Test-Path -Path \$file)) {
                  Write-Error "Missing required file: \$file"
                  \$missingFiles = \$true
              }
          }

          if (\$missingFiles) {
              Write-Error "Some required files are missing. Please ensure they are present. Press any key to exit"
              \$null = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
              exit 1
          }

          reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /t REG_DWORD /f /v "AllowDevelopmentWithoutDevLicense" /d "1"

          \$VMP = Get-WindowsOptionalFeature -Online -FeatureName 'VirtualMachinePlatform'
          if (\$VMP.State -ne "Enabled") {
              Enable-WindowsOptionalFeature -Online -NoRestart -FeatureName 'VirtualMachinePlatform'
              Clear-Host
              Write-Warning "Need restart to enable virtual machine platform\`r\`nPress y to restart or press any key to exit"
              \$key = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
              If ("y" -eq \$key.Character) {
                  Restart-Computer -Confirm
              }
              Else {
                  exit 1
              }
          }

          Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Path vclibs.appx
          Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Path xaml.appx

          \$Installed = \$null
          \$Installed = Get-AppxPackage -Name 'MicrosoftCorporationII.WindowsSubsystemForAndroid'

          If ((\$null -ne \$Installed) -and (-not (\$Installed.IsDevelopmentMode))) {
              Clear-Host
              Write-Warning "There is already one installed WSA. Please uninstall it first.\`r\`nPress y to uninstall existing WSA or press any key to exit"
              \$key = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
              If ("y" -eq \$key.Character) {
                  Remove-AppxPackage -Package \$Installed.PackageFullName
              }
              Else {
                  exit 1
              }
          }
          Clear-Host
          Write-Host "Installing MagiskOnWSA..."
          Stop-Process -Name "wsaclient" -ErrorAction "silentlycontinue"
          # This assumes AppxManifest.xml is in the current directory (which is ${{ matrix.arch }})
          Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Register .\AppxManifest.xml
          if (\$?) {
              Finish
          }
          Elseif (\$null -ne \$Installed) {
              Clear-Host
              Write-Host "Failed to update, try to uninstall existing installation while preserving userdata..."
              Remove-AppxPackage -PreserveApplicationData -Package \$Installed.PackageFullName
              Add-AppxPackage -ForceApplicationShutdown -ForceUpdateFromAnyVersion -Register .\AppxManifest.xml
              if (\$?) {
                  Finish
              }
          }
          Write-Host "All Done\`r\`nPress any key to exit"
          \$null = \$Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
          EOF
          shopt -s extglob
          # This command will remove everything inside ${{ matrix.arch }} except system.img and vendor.img
          # It's important that vclibs.appx, xaml.appx, and AppxManifest.xml are copied *before* this line
          # if they are meant to persist.
          # The current order is fine, as cp happens before this rm.
          sudo rm -rf -- ${{ matrix.arch }}/!(system.img|vendor.img)
      - name: Generate artifact name
        run: |
          root="${{ github.event.inputs.root_sol }}"
          if [[ "$root" = "none" ]]; then
            name1=""
          elif [[ "$root" = "" ]]; then
            name1="-magisk"
          else
            name1="-${root}"
          fi
          echo "artifact_name=WD${name1}_${{ matrix.arch }}" >> $GITHUB_ENV
      - name: Upload Waydroid
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.artifact_name }}
          path: "./${{ matrix.arch }}/*"
